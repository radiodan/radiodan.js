#!/usr/bin/env node
var amqp     = require('amqplib'),
    program  = require('optimist'),
    readline = require('readline'),
    Q        = require('q');

var queueHost = 'localhost',
    waitForConnection,
    command,
    argv,
    radioId,
    channel;

/*
  Command-line options
*/
var argv = program
             .usage('Usage: $0')
             .demand('id')
             .describe('id', 'ID of radio instance to control')
             .describe('random.directory', 'Play random tracks from specified directory')
             .describe('play.stream', 'Play an internet stream')
             .describe('volume.value', 'Set to an absolute volume')
             .describe('volume.diff', 'Set to an offset of current volume (+/-N)')
             .describe('host', 'Set message queue hostname. Default: localhost')
             .describe('interactive', 'Set-up interactive command mode')
             .alias('i', 'interactive')
             .argv;

// Override message queue host
if (argv.host && typeof argv.host === 'string') {
  queueHost = argv.host;
}

// Extract required radio id or error
if (argv.id && typeof argv.id === 'string') {
  radioId = argv.id;
} else {
  console.log('Missing required arguments: id');
  program.showHelp();
  process.exit();
}

// Extract command from argv
command = commandForArg(argv);

if (!command && !argv.interactive) {
  program.showHelp();
  console.log('Error: command option not given - nothing to do\n');
  process.exit();
}

var connectionPromise = connect(amqp.connect('amqp://' + queueHost));

if (argv.interactive) {
  interactiveCommandPrompt(connectionPromise);
} else {
  sendCommand(command, radioId, connectionPromise, doneAndExit);
}

/*
  Starts an interactive command prompt
  for options
*/
function interactiveCommandPrompt(connectionPromise) {

  var rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  rl.write('Interactive mode\n');
  rl.write('Enter commands to send to this radio\n');
  rl.write('Type exit to quit\n');
  rl.write('  e.g. --volume.value=10\n');
  rl.prompt('>');

  // Process input line
  rl.on('line', function (cmd) {
    processInputLine(cmd, connectionPromise, function (success) {
      if (!success) {
        console.log('Error: Command not found');
      }
      rl.prompt('>');
    });
  });
}

/*
  Process a string of input from readline
  and execute commands found
*/
function processInputLine(cmd, connectionPromise, done) {
  var args,
      opts,
      command;

  if (cmd === 'exit') {
    console.log('Goodbye.\n');
    process.exit();
  }

  // Merge args with those passed into command
  // to ensure that any required options are supplied
  args = cmd.split(' ')
            .concat(process.argv);

  opts    = program.parse(args);
  command = commandForArg(opts);

  if (command) {
    sendCommand(command, radioId, connectionPromise, function () {
      done(true);
    });
  } else {
    done(false);
  }
}

/*
  Connect to message queue
*/
function connect(waitForConnection) {
  var deferred = Q.defer();

  waitForConnection.then(function (connection) {
    var waitForChannel = connection.createConfirmChannel();
    waitForChannel.then(function (ch) {
      channel = ch;
      var waitForExchange = channel.assertExchange('radiodan', 'topic');
      waitForExchange.then(function () {
        deferred.resolve(channel);
      }, error);
    }, error);
  }, error);

  return deferred.promise;
}

/*
  Send a command to Rabbit MQ
*/
function sendCommand(command, radioId, connectionPromise, done) {
  command = JSON.stringify(command);
  connectionPromise.then(function (channel) {
    channel.publish('radiodan', topicForId(radioId), new Buffer(command), {}, done);
    console.log('published to %s', topicForId(radioId), command);
  });
}

/*
  Given a Optimist-parsed argv object, return the
  corresponding radiodan command object or null
  if no command found.
*/
function commandForArg(argv) {
  var command;

  if (argv.volume) {
    command = argv.volume;
    command.action = 'volume';
  } else if (argv.random) {
    command = argv.random;
    command.action = 'random';
  } else if (argv.play && argv.play.stream) {
    command = {
      action: 'play',
      playNow: true,
      playlist: [ argv.play.stream ]
    }
  }
  return command;
}

/*
  Return a topic key for a given radio id
*/
function topicForId(id) {
  return 'radio.' + id + '.command';
}

/*
  Log an error
*/
function error(err) {
  console.error('Error', err.stack);
}

/*
  Log 'done' and then exit
*/
function doneAndExit(err, ok) {
  console.log('Done');
  process.exit();
}
